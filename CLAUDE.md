# dl4to-multiscale — AI Assistant Guide

## Project Overview

`dl4to-multiscale` is a multiscale TPMS (Triply Periodic Minimal Surface) lattice topology optimization framework built on top of [DL4TO](https://github.com/dl4to/dl4to), a PyTorch-based 3D topology optimization library. It extends the original single-scale SIMP density method with TPMS microstructure parameterization, numerical homogenization, anisotropic FDM solving, and high-resolution reconstruction — enabling end-to-end differentiable optimization from micro to macro scale.

**Language:** Python 3.9+
**Core dependency:** PyTorch (all operations are autograd-compatible)
**Build system:** [nbdev](https://nbdev.fast.ai/) (notebooks are source of truth for the original dl4to modules)
**License:** Apache 2.0

---

## Repository Structure

```
dl4to-multiscale/
├── dl4to/                        # Main Python package
│   ├── __init__.py               # Package version (0.0.1)
│   │
│   ├── # ── NEW MULTISCALE MODULES (7 files) ──
│   ├── tpms.py                   # Phase 1: TPMS geometry (6 surface types)
│   ├── homogenization.py         # Phase 2: Numerical homogenization & lookup table
│   ├── multiscale_pde.py         # Phase 3: Anisotropic FDM PDE solver
│   ├── multiscale_representer.py # Phase 4: Voxel parameterization (vf + TPMS type)
│   ├── multiscale_solver.py      # Phase 5a: SIMP-style optimization loop
│   ├── multiscale_criteria.py    # Phase 5b: Smoothness & volume constraints
│   ├── reconstruction.py         # Phase 6: Macro → micro voxel reconstruction
│   │
│   ├── # ── EXISTING CORE MODULES (unmodified except plotting.py) ──
│   ├── pde.py                    # FDM solver, derivative operators, autograd linear solver
│   ├── problem.py                # Problem definition (domain, BCs, forces)
│   ├── solution.py               # Solution container (density field + PDE cache)
│   ├── criteria.py               # Compliance, VolumeConstraint, Binariness, etc.
│   ├── topo_solvers.py           # SIMP solver, TopoSolver base class
│   ├── density_filters.py        # RadialDensityFilter and other spatial filters
│   ├── density_representers.py   # Design variable parameterization
│   ├── plotting.py               # PyVista/Plotly visualization (minor compat patch)
│   ├── datasets.py               # Dataset loading utilities
│   ├── models.py                 # Neural network models for topology optimization
│   ├── preprocessing.py          # Data normalization/transformation
│   └── utils.py                  # Stress computation, tensor helpers
│
├── test_phases.py                # Integration test suite (6 phases)
├── notebooks/                    # Jupyter notebooks (nbdev source for original modules)
│   └── index.ipynb, criteria/, pde/, problem/, solution/, topo_solvers/, ...
├── docs/                         # Jekyll documentation (generated by nbdev)
├── README.md                     # Project overview (Chinese)
├── SCIENTIFIC_RESEARCH_GUIDE.md  # Research methodology and reproducibility guide
├── CONTRIBUTING.md               # Contribution guidelines
├── setup.py                      # Package setup (reads from settings.ini)
├── settings.ini                  # nbdev configuration
├── requirements.txt              # Pinned dependency list
├── environment.yml               # Conda environment definition
├── Makefile                      # Build targets
└── precommit.sh                  # Pre-commit hook script
```

---

## Module Architecture

### Class Hierarchy

```
PDESolver (abstract, pde.py)
├── UnpaddedFDM            — standard isotropic FDM
├── FDM                    — padded version
└── MultiscaleFDM          — anisotropic per-voxel stiffness (multiscale_pde.py)

TopoSolver (abstract, topo_solvers.py)
├── SIMP                   — standard density-based SIMP
└── MultiscaleSIMP         — multiscale TPMS-based SIMP (multiscale_solver.py)

Criterion (abstract, criteria.py)
└── UnsupervisedCriterion
    ├── Compliance, VolumeConstraint, Binariness   (criteria.py)
    ├── GradedPropertyConstraint                   (multiscale_criteria.py)
    └── LocalVolumeConstraint                      (multiscale_criteria.py)

nn.Module
├── DensityRepresenter     — standard density parameterization (density_representers.py)
└── MultiscaleRepresenter  — vf + TPMS type parameterization  (multiscale_representer.py)
```

### Data Flow (End-to-End Optimization)

```
MultiscaleRepresenter
  ├─ vf_logit  (learned param) ──sigmoid──► vf ∈ [vf_min, vf_max]
  ├─ type_logits (learned param) ─softmax─► weights per TPMS type
  └─ HomogenizationLookupTable.batch_interpolate_9x9(weights, vf)
         └──► C_field: (9, 9, nx, ny, nz)  [per-voxel stiffness tensor]
                  │
                  ▼
         MultiscaleFDM.solve_pde(solution)
           ├─ _J(u)  ──────────────────────► strain ε: (9, nx, ny, nz)
           ├─ _apply_C_eff(ε, C_field) ────► stress σ: (9, nx, ny, nz)
           └─ AutogradLinearSolver ─────────► u, σ, σ_vm  (adjoint backprop)
                  │
                  ▼
         Criterion(solutions)
           ├─ Compliance(alpha)
           ├─ VolumeConstraint(max_volume_fraction)
           ├─ GradedPropertyConstraint(max_gradient)
           └─ LocalVolumeConstraint(max_local_vf)
                  │
                  ▼
         loss.backward()
           └──► gradients flow: loss → u → C_field → vf_logit, type_logits
```

---

## Module Details

### Phase 1 — `dl4to/tpms.py` (TPMS Geometry)

**Key exports:**
- `TPMS_REGISTRY`: `dict[str, type]` mapping names to TPMS classes
  - Keys: `'gyroid'`, `'schwarz_p'`, `'schwarz_d'`, `'neovius'`, `'fischer_koch'`, `'iwp'`
- `Gyroid`, `SchwarzP`, `SchwarzD`, `Neovius`, `FischerKoch`, `IWP`: callable classes, signature `(X, Y, Z, period=1.0) -> phi`
- `tpms_density_field(tpms_fn, grid_size, threshold, smooth_width) -> Tensor (1, N, N, N)`: sigmoid-based soft voxelization
- `compute_volume_fraction(density) -> float`
- `find_threshold_for_vf(tpms_fn, target_vf, grid_shape) -> float`: binary search

All operations are PyTorch autograd-compatible.

### Phase 2 — `dl4to/homogenization.py` (Numerical Homogenization)

**Key exports:**
- `NumericalHomogenizer(E, nu, dtype)`: computes 6×6 Voigt stiffness `C_eff`
  - `.homogenize(density: Tensor) -> Tensor (6, 6)`: from arbitrary density field
  - `.homogenize_tpms(tpms_name, vf, resolution) -> Tensor (6, 6)`: convenience wrapper
- `HomogenizationLookupTable(tpms_types, n_samples, resolution, E, nu)`:
  - `.precompute(verbose=True)`: builds cache for all (type, vf) pairs
  - `.save(path)` / `.load(path)`: disk persistence via `torch.save`/`torch.load`
  - `.batch_interpolate_9x9(type_weights, vf_field) -> Tensor (9, 9, nx, ny, nz)`: differentiable interpolation for use in FDM
- `_get_isotropic_C_voigt(E, nu) -> Tensor (6, 6)`: analytical reference

**Accuracy:** Full-density unit cell achieves `< 1e-6` relative error vs. analytical solution.

### Phase 3 — `dl4to/multiscale_pde.py` (Anisotropic FDM)

**Key exports:**
- `MultiscaleFDM(PDESolver)`:
  - `.set_stiffness_field(C_field: Tensor (9, 9, nx, ny, nz))`: set per-voxel stiffness
  - `.assemble_tensors(problem)`: initialize FDM operators (mirrors existing FDM API)
  - `.solve_pde(solution) -> (u, sigma, sigma_vm)`: solve with anisotropic constitutive law
  - `._apply_C_eff(epsilon, C_field)`: `σ_i = C_ij(x) · ε_j(x)` per voxel
  - `._A(u, C_field)`: system operator `y = Jᵀ · C_eff · J · u`

**Note:** Reuses `_J`, `_J_adj`, `FDMDerivatives`, `FDMAssembly`, `AutogradLinearSolver` from `pde.py`.

### Phase 4 — `dl4to/multiscale_representer.py` (Parameterization)

**Key exports:**
- `MultiscaleRepresenter(nn.Module)`:
  - Constructor: `(problem, homogenization_table, initial_vf=0.3, vf_min=0.05, vf_max=0.95, use_filter=True, filter_radius=2.0, initial_temperature=10.0)`
  - Learned parameters: `vf_logit (1, nx, ny, nz)`, `type_logits (n_types, nx, ny, nz)`
  - `.forward() -> (C_field, vf)`: main forward pass
  - `.get_type_weights() -> Tensor (n_types, nx, ny, nz)`: softmax weights (sum to 1 per voxel)
  - `.anneal_temperature(factor)`: reduce softmax temperature for sharper type selection

### Phase 5a — `dl4to/multiscale_solver.py` (Optimization Loop)

**Key exports:**
- `MultiscaleSIMPIterator`: single iteration object
  - `.forward(solutions, C_field) -> loss`: forward pass + backward
- `MultiscaleSIMP(TopoSolver)`:
  - Constructor: `(criterion, homogenization_table, n_iterations=100, lr=3e-2, tpms_types=['gyroid', 'schwarz_p'], ...)`
  - `.__call__(problems) -> solutions`: full optimization loop
  - Auto-creates `MultiscaleRepresenter`, `MultiscaleFDM`, iterator internally

### Phase 5b — `dl4to/multiscale_criteria.py` (Constraints)

**Key exports:**
- `GradedPropertyConstraint(UnsupervisedCriterion)`:
  - Constructor: `(max_gradient=0.5, weight=1.0)`
  - Penalizes spatial gradient of TPMS parameters between adjacent voxels
- `LocalVolumeConstraint(UnsupervisedCriterion)`:
  - Constructor: `(max_local_vf=0.5, kernel_size=3, weight=1.0)`
  - Penalizes local regions exceeding volume fraction limit

Both are composable with `+` and scalar multiplication, following existing `Criterion` API.

### Phase 6 — `dl4to/reconstruction.py` (High-Resolution Reconstruction)

**Key exports:**
- `TPMSReconstructor`:
  - Constructor: `(upscale_factor=8, boundary_smooth_sigma=1.0)`
  - `.reconstruct(problem, tpms_params) -> Tensor (1, nx*f, ny*f, nz*f)`: soft density field
  - `.reconstruct_binary(problem, tpms_params) -> Tensor (1, nx*f, ny*f, nz*f)`: thresholded binary
  - `tpms_params` dict requires keys: `'vf'`, `'type_weights'`, `'tpms_types'`
  - Internal cache prevents redundant unit cell recomputation

---

## Development Commands

### Running Tests

```bash
# Run all 6 phase integration tests
python test_phases.py

# Expected output: "ALL PHASES PASSED!"
```

Tests cover: TPMS geometry, homogenization accuracy, anisotropic FDM, representer gradients, criteria, and reconstruction.

### Installation

```bash
# Fresh environment
conda create -n dl4to python=3.11 -y
conda activate dl4to
pip install -e .

# Existing environment with custom PyTorch (avoids dependency overwrite)
pip install -e . --no-build-isolation --no-deps
```

### GPU Check

```bash
python -c "import torch; print('CUDA:', torch.cuda.is_available(), '| count:', torch.cuda.device_count())"
```

### nbdev Build (for original notebook-driven modules)

```bash
nbdev_build_lib       # Generate Python from notebooks
nbdev_test_nbs        # Test notebooks
nbdev_build_docs      # Generate docs from notebooks
make all              # Build library + docs
make sync             # Sync notebooks ↔ library
```

### Pre-commit Hook

```bash
nbdev_install_git_hooks   # Install pre-commit hook that cleans notebooks
```

---

## Key Conventions

### Tensor Shapes

| Tensor | Shape | Description |
|--------|-------|-------------|
| Design field (density) | `(1, nx, ny, nz)` | Single-channel voxel grid |
| Displacement field | `(3, nx, ny, nz)` | 3D displacement per voxel |
| Strain / stress field | `(9, nx, ny, nz)` | 9-component (3×3 Voigt-flattened) |
| Stiffness field C | `(9, 9, nx, ny, nz)` | Per-voxel 9×9 stiffness tensor |
| Volume fraction (macro) | `(1, nx, ny, nz)` | Scalar per voxel |
| Type weights | `(n_types, nx, ny, nz)` | Softmax-normalized per voxel |
| Voigt stiffness matrix | `(6, 6)` | Symmetric homogenized stiffness |

### Differentiability

All new modules are designed for full PyTorch autograd compatibility:
- TPMS functions use standard `torch` math operations
- Lookup table interpolation is linear and differentiable
- FDM uses `AutogradLinearSolver` from `pde.py` for adjoint-based backprop
- Sigmoid/softmax parametrize design variables to bounded ranges

### Adding a New TPMS Type

1. Create a callable class in `dl4to/tpms.py`:
   ```python
   class MyTPMS:
       def __call__(self, X, Y, Z, period=1.0):
           # Return implicit surface field phi (positive = solid)
           return torch.cos(2*pi*X/period) + ...
   ```
2. Register it: `TPMS_REGISTRY['my_tpms'] = MyTPMS`
3. All downstream code (homogenization, representer, reconstruction) picks it up automatically via `TPMS_REGISTRY`.

### Adding a New Criterion

Subclass `UnsupervisedCriterion` from `dl4to/criteria.py`:
```python
from dl4to.criteria import UnsupervisedCriterion

class MyCriterion(UnsupervisedCriterion):
    def forward(self, solutions):
        # solutions: list of Solution objects
        # return: scalar Tensor
        ...
```

Use `+` and `*` for composition: `criterion = Compliance() + 0.5 * MyCriterion()`.

### Problem Definition

```python
from dl4to.problem import Problem
from dl4to.pde import UnpaddedFDM

problem = Problem(
    E=1.0,              # Young's modulus
    ν=0.3,              # Poisson's ratio
    σ_ys=1.0,           # Yield stress
    h=1.0,              # Voxel size
    Ω_dirichlet=...,    # (3, nx, ny, nz) int32: 1 = constrained DOF
    Ω_design=...,       # (1, nx, ny, nz) int32: -1 = void, 0 = design, 1 = solid
    F=...,              # (3, nx, ny, nz) float32: applied forces
    pde_solver=UnpaddedFDM(),
)
```

---

## Backward Compatibility

- **All existing `dl4to` interfaces are preserved** — `Problem`, `Solution`, `SIMP`, `Compliance`, `VolumeConstraint`, etc. work exactly as before.
- **Only change to existing files:** `dl4to/plotting.py` line 17 wraps `pv.set_jupyter_backend('pythreejs')` in a `try/except` for newer PyVista compatibility.
- New modules add no new package dependencies (uses only PyTorch, NumPy, SciPy, which were already required).

---

## Complete Usage Example

```python
from dl4to.tpms import TPMS_REGISTRY
from dl4to.homogenization import HomogenizationLookupTable
from dl4to.multiscale_solver import MultiscaleSIMP
from dl4to.multiscale_criteria import GradedPropertyConstraint, LocalVolumeConstraint
from dl4to.reconstruction import TPMSReconstructor
from dl4to.criteria import Compliance, VolumeConstraint
from dl4to.problem import Problem
from dl4to.pde import UnpaddedFDM
import torch

# 0. Define problem
nx, ny, nz = 20, 10, 10
Omega_dirichlet = torch.zeros(3, nx, ny, nz, dtype=torch.int32)
Omega_dirichlet[:, 0, :, :] = 1
Omega_design = torch.zeros(1, nx, ny, nz, dtype=torch.int32)
F = torch.zeros(3, nx, ny, nz)
F[1, -1, ny//2, nz//2] = -1.0

problem = Problem(E=1.0, ν=0.3, σ_ys=1.0, h=1.0,
                  Ω_dirichlet=Omega_dirichlet, Ω_design=Omega_design,
                  F=F, pde_solver=UnpaddedFDM())

# 1. Precompute homogenization lookup table
table = HomogenizationLookupTable(
    tpms_types=['gyroid', 'schwarz_p'],
    n_samples=19, resolution=16, E=1.0, nu=0.3
)
table.precompute()
table.save('lookup_table.pt')  # Cache to disk

# 2. Compose optimization objective
criterion = (
    Compliance(alpha=1e-9)
    + 0.1 * VolumeConstraint(max_volume_fraction=0.3)
    + 0.05 * GradedPropertyConstraint(max_gradient=0.3)
)

# 3. Run multiscale optimization
solver = MultiscaleSIMP(
    criterion=criterion,
    homogenization_table=table,
    n_iterations=100,
    lr=3e-2,
    tpms_types=['gyroid', 'schwarz_p'],
)
solution = solver([problem])[0]

# 4. High-resolution reconstruction
reconstructor = TPMSReconstructor(upscale_factor=8)
hr_density = reconstructor.reconstruct(problem, solution.tpms_params)
hr_binary = reconstructor.reconstruct_binary(problem, solution.tpms_params)
```

---

## Testing Details

`test_phases.py` runs 6 independent phase tests:

| Phase | Function | What is verified |
|-------|----------|-----------------|
| 1 | `test_phase1()` | All 6 TPMS functions, density field shape, volume fraction control (±0.02), autograd |
| 2 | `test_phase2()` | Full-density accuracy (`< 1e-6` rel err), C_eff symmetry (`< 1e-10`), monotonicity with VF |
| 3 | `test_phase3()` | Isotropic degradation: uniform C_field → matches standard `UnpaddedFDM` |
| 4 | `test_phase4()` | Output shapes `(9,9,nx,ny,nz)` and `(1,nx,ny,nz)`, non-zero gradients, type weight normalization |
| 5 | `test_phase5()` | `GradedPropertyConstraint` and `LocalVolumeConstraint` return correct scalar penalties |
| 6 | `test_phase6()` | Reconstruction shape `(1, nx*f, ny*f, nz*f)`, VF in range, solid region density > 0.99, binary values |

---

## Research Notes

See `SCIENTIFIC_RESEARCH_GUIDE.md` for:
- Environment and version pinning methodology
- Baseline verification requirements
- Seed fixing for reproducibility
- Recommended experiment directory structure
- Ablation study guidance
- Paper reporting standards

---

## Dependencies

Core (no additions over original dl4to):
- `torch` — all computation, autograd
- `numpy` — array utilities
- `scipy` — sparse solvers (used internally by PDE solver)

Visualization (optional):
- `plotly`, `matplotlib` — 2D plots
- `pyvista`, `vtk` — 3D mesh rendering (requires downgrade for older PyVista)

Build/dev:
- `nbdev` — notebook-driven development for original modules
- `pytest`, `hypothesis` — testing

---

## Git Workflow

Active development branch: `claude/add-claude-documentation-e7qNt`
Main branch: `master`

```bash
git checkout claude/add-claude-documentation-e7qNt
# Make changes
git add <specific files>
git commit -m "Descriptive message"
git push -u origin claude/add-claude-documentation-e7qNt
```
